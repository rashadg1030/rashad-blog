---
title: Building A Web Application with Haskell
date: 2019-06-20
---

For the next couple of months I will be working on the web application [issue-wanted](https://summerofcode.withgoogle.com/projects/#5585364545175552) for GSoC (Google Summer of Code) and documenting my experience. As I've mentioned before, there isn't a lot of easily accesible material out there for learning how to build web applications with Haskell and I want to change that. A lot of Haskellers that I meet have gotten to the point where they know the basics of Haskell, probably have a few small Haskell projects under their belt, but are having trouble applying their knowledge to a non-trivial, "real-world" application. One of the biggest hurdles that you go up against when building your first big Haskell project is deciding on how to structure it. Unlike OOP, there isn't a lot of material on functional programming design patterns\[1\] and how to structure functional programs properly. Haskell is particularly interesting becasue the language is constantly evolving and people are always finding new methods for structuring programs all the time. Should you use mtl-style, free monads, or freer monads? Are typeclasses bad\[2\]?

Nobody knows for sure, but for now there are a two architectural techniques/ideas that I feel like most of the Haskell community can agree are good practices:

* [Three layer architecture (AKA Functional Core, Imperative Shell)]()
* [ReaderT Design Pattern]()

I'll be applying these concepts to issue-wanted with the help of my mentors Dmitrii and Veronika, both of whom have lots of experience in building Haskell projects.
Dmitrii and Veronika are the founders of [Kowainik](https://kowainik.github.io/), a non-profit organization focused on making the world a better place through well designed software. They've a built a wide variety of very helpful Haskell libraries including `colog`, `relude`, and `summoner`. Dmitrii and Veronika also work with Haskell at [Holmusk](https://www.holmusk.com/), a health tech company based in Singapore. `issue-wanted` is based on a template project used at Holmusk for their web applications called [three-layer](https://github.com/Holmusk/three-layer). The great thing about `three-layer` is that it avoids the use of opinionated web frameworks, and instead uses a smart combination of well-documented libraries such as `servant` and `postgresql-simple`. The three-layer template is simple, modular, and can be moulded to fit the needs of most CRUD applications. Feel free to clone the `three-layer` repository and play around with it to get a feel for how to apply the techniques used in `three-layer` to your own projects. For those who need some guidance, I recommend you read the next few blog posts I'll be writing about building `issue-wanted`. You can think of it as a case study on building a web application in Haskell using the methods outlined above. I plan on writing about the following topics: 

* The Application Monad and ReaderT Pattern
* Using Servant to Define Your API 
* Setting Up a Database and Using Postgresql-simple
* Error Handling in Haskell
* Logging for Your Application and Other External Effects
* Writing Tests for Your Application

If you have a solid understanding of the Haskell basics and are looking to understand concepts like monads, monad transformers, and Haskell language extensions in depth then this is the right series for you! I will try my best to break everything down in a simple manner with as little mathematical jargon as possible. 

Before I start I would like to quickly summarize what `issue-wanted` is, and go over some of the design choices me and my mentors made and why. Here's a short description of what `issue-wanted` is trying to accomplish from the `README.md`.

> issue-wanted is a web application focused on improving the open-source Haskell community by centralizing GitHub issues across many Haskell repositories into a single location. The goals of issue-wanted are to make it easier for programmers of all skill levels to find Haskell projects to contribute to, increase the number of contributions to open-source Haskell projects, and encourage more programmers to become a part of the Haskell community.

Here is a diagram of `issue-wanted`'s architecture:

![Issue-wanted architecture](issue-wanted.png)

As you can see, `issue-wanted` has five main components:

1. GitHub API

   In order to aggregate all of the Haskell issues and repositories we need to interact with the GitHub API. To do that, we are using phadej's [github library](). This library provides functions that are essentially wrappers around the GitHub REST API. They allow us to query the API with convenient functions that take query strings as arguements. For example:
   
   ```
   Code Here
   ```

   This function returns all open, Haskell issues with the label `good first issue`.
   
   At first we considered using the GitHub GraphQL API (V4), but we thought the github library was to convenient to pass up.

2. PostgreSQL Database
   
   We will be using a PostgreSQL database to store all the Haskell repositories and issues we get from querying the GitHub API. To bridge the gap between our application and database we will be using the [`postgresql-simple`]() library. Postgresql-simple is a "Mid-Level PostgreSQL client library" that provides many useful functions for interacting with a PostgreSQL database. You may be wondering why we didn't go with a higher-level, more type safe, EDSL library like `opaleye`, `esqueletto`, or `squeal`. The reason why is beacuse those libraries are too "powerful" for what we need. Our database schema isn't super complex, and our most complex queries are basic join statements. `postgresql-simple` simply allows us to execute raw SQL from our Haskell code.

3. Asynchronous Worker

   The asynchronous worker will be responsible for querying the GitHub API and syncing the database up with any new Haskell issues and repositories. The details of how the worker will be implemented are still a bit blurry, but it will be scheduled to do sync the database regularly to ensure that the most recent issues and repositories are displayed to the user.  

4. issue-wanted API

    This is the API that the front-end of the application will be hitting. We easily decided to use `servant` to define our API endpoints. Servant is a well-documented,battle-tested Haskell library, and is probably the best example of using type level programming to solve an interesting problem. With `servant` you can define your API as types and easily compose different APIs at will using the various type operators that `servant` provides. You then write handlers for your endpoints and then voila! It is not required to understand type level programming in depth to use `servant`. Here's an example of simple API:

    ```
    Code Here
    ```

    As you can see, it's really straightforward.

5. Front-End

   Blah Blah

As some of you may know, the Haskell web development ecosystem is pretty well developed, so it was a challenge to choose from the plethora of libraries at our disposal.  
