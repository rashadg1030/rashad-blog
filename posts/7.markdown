---
title: Adding a Custom Effect to Issue-Wanted
date: 2019-07-13
---

Over the past few weeks I've been making steady progress on the [`issue-wanted`]() project I'm working on for GSoC 2019. Today I would like to present my work on adding a custom monad/effect to `issue-wanted` and what I learned during the process. It's only about half way through the Summer, and thanks to my mentors I've learned so much!


As I said in my last post there is still an ongoing debate on what is the best way to structure Haskell programs. As far as I know, the most popular method used today is monad transformers, also known as "mtl-style". Monad transformers give the programmer the ability to combine, or "stack", different monads together to create a monad that suits their needs. You've probably learned of the idea that monads can be thought of as computations or actions, each with a specific set of rules on how to compose them\[1\]. I like to think of monads as powerups in a video game; each one gives the programmer a unique ability. With the power to mix and match different monads comes the responsibility of building your own custom monad. When we need to operate within a certain context, but the available monads don't describe it well enough, we need to create our own. Here's an example of a problem I faced when working on a feature of `issue-wanted`. If you don't know already, the goal of `issue-wanted` is to be a web application that programmers can use to quickly find open-source Haskell projects to contribute to. Me and my mentors want to make sure that people are able to find the right project for them, and so we thought displaying the Haskell repository along with the category names that populate the project's `.cabal` file would be a nice feature. Creators of Haskell projects have the option to add a comma-seperated list of values to the `category` field of their `.cabal` file. Here's the `.cabal` file for the `issue-wanted` project for example:

```
category: Web, Application
```

This metadata is very useful when using [Hackage](http://hackage.haskell.org/packages/) to browse for packages.

Our challege was to figure out how to fetch this metadata and store it in our database. An easy solution would've been to just use the GitHub API to retrieve the file contents, but we already use the GitHub API pretty extensively throughout other parts of the application and thought we might risk going over the API rate-limit. A better solution we decided to implement for this problem is to download the file from directly from GitHub. Are `Repo` type is defined as follows:

~~~ {.haskell .numberLines}
-- | Data type representing a GitHub repository
data Repo = Repo
    { repoOwner      :: !RepoOwner
    , repoName       :: !RepoName
    , repoDescr      :: !Text
    , repoCategories :: !(SqlArray Category)
    } deriving stock    (Eq, Generic, Show)
      deriving anyclass (ToJSON, FromRow, ToRow)
~~~

We knew we could construct a URL for the `.cabal` file with the `repoOwner` and `repoName` fields, and use it download its contents for parsing. The funtion would look like this:

~~~ {.haskell .numberLines}
downloadFile :: Url -> ByteString
~~~

But downloading a file from the Internet is not a pure function! `downloadFile` needs to operate within some sort of monadic context:

~~~ {.haskell .numberLines}
downloadFile :: (SomeContext m) => Url -> m ByteString
~~~


